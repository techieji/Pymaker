{"r": "Run a command. This is a wrapper for either ``os.system`` or\n``subprocess.call``, depending on whether the argument is a string\nor a list. Example:\n\n.. code:: python\n\n   >>> r('echo \"This is a test\"')\n   Pymaker: echo \"This is a test\"\n   This is a test\n   >>> r(['echo', 'This is a test'])\n   Pymaker: echo This is a test\n   This is a test\n   \nUse this function instead of ``os.system`` or ``subprocess.call`` when\ncalling shell commands.", "RecursiveDefinitionError": "An error raised when a recursive definition is detected.", "declare_argument": "Declare a command-line argument. Acts as a wrapper around ``argparse.ArgumentParser.add_argument``.", "command": "Define a command. Dependencies can be declared through the ``deps`` argument. Help for\nthat command can be defined through the docstring. A command name can be provided through\nthe ``name`` option, but it defaults to the function's name, which is probably what you\nwant. Example:\n\n.. code:: python\n\n   @command\n   def fn():\n       \"This is a help string.\"\n       pass\n   \n   @command(deps=['fn'])\n   def fn2():\n       pass\n       \n  @command(name='notme')\n  def fn3():\n      pass\n\n", "build_direc": "Builds a directory of all commands.", "call_command": "Call a command, given a command name, a directory, and a namespace object.", "make_help_message": "Makes a help message from the Makefile.py present in the directory.", "main": "Main function. Can be added like so to make any file a Makefile:\n\n.. code:: python\n\n   main(__file__)\n   \nThen, you can run that file like a Makefile by doing ``python <filename> <command>``."}